<!doctype html>
<html>
<head>
    <title>Nevado - Spring meets Amazon's cloud services - Performance</title>
    <meta name="description" content="Enable field selectors and call aggregation on Java-based REST servers." />
    <meta name="keywords" content="yoga,yoga rest,field selector,java rest,java restful,yoga api,rest aggregate,rest open source" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <link href="css/style.css" rel="stylesheet"/>
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', '']);
        _gaq.push(['_setDomainName', 'skyscreamer.org']);
        _gaq.push(['_trackPageview']);

        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();

    </script>
</head>
<body>
<header>
    <h1>Nevado</h1>
</header>
<nav>
    <ul>
        <li><a class="intro" href="./">Introduction</a></li>
        <li><a class="performance" href="">Performance</a></li>
        <li><a class="quickstart" href="quickstart.html">Quickstart</a></li>
        <li><a class="download" href="https://github.com/skyscreamer/nevado/downloads">Download</a></li>
        <li><a class="contrib" href="https://github.com/skyscreamer/nevado">Contribute</a></li>
        <li><a class="wiki" href="https://github.com/skyscreamer/nevado/wiki">Wiki</a></li>
    </ul>
</nav>
<section>
    <a name="performance"></a>
    <h2>Performance</h2>
    <p>Nevado JMS uses REST calls to Amazon web services under the covers, so depends closely on network latency.
    Here are a set of informal tests that we're run to provide an idea of what's possible:</p>
    <table class="perf_table">
        <tr><th>Message Size (bytes)</th><th># of Threads</th><th>Send Rate (msg/sec)</th><th>Receive Rate (msg/sec)</th></tr>
        <tr><td>1</td><td>1</td><td>34</td><td>23</td></tr>
        <tr class="alt_row"><td>1</td><td>2</td><td>71</td><td>45</td></tr>
        <tr><td>10k</td><td>1</td><td>23</td><td>20</td></tr>
        <tr class="alt_row"><td>10k</td><td>2</td><td>48</td><td>42</td></tr>
    </table>
    <p>Nevado+SQS is comparable speed-wise to <a href="http://bhavin.directi.com/rabbitmq-vs-apache-activemq-vs-apache-qpid/">ActiveMQ
        in persistent mode</a>, which is to say it's not breath-taking.  That said, this solution <u>scales
        linearly</u>.  Add threads on your box until you max out your server resources.  Then add boxes.
        You're not going to use this to build an algorithmic stock trading platform, but it is a good fit for applications
        that need to scale traffic horizontally and indefinitely,.</p>
</section>
<section>
    <a name="compliance"></a>
    <h2>JMS Compliance</h2>
    <p>Nevado JMS is not 100% compliant,
        <b><a href="https://github.com/skyscreamer/nevado/wiki/Master-Feature-Grid">but it's close</a></b>.
        Nevado creates a lot of JMS functionality itself, and hides the limitations of SQS where possible.
        It was developed against version 1.1 of the specification, and we hope to update it to 2.0 when that becomes
        final in 2013.</p>
</section>
<section>
    <a name="supported"></a>
    <h2>Supported</h2>
    <ul>
        <li>Multi-threading</li>
        <li>Messages containing Java objects, XML, JSON, etc..</li>
        <li>Supports standard JMS headers and properties</li>
        <li>Full support for all JMS message types: TextMessage, ObjectMessage, MapMessage, StreamMessage, BytesMessage</li>
        <li>Supports messages from other JMS providers</li>
        <li>Both synchronous or asynchronous delivery</li>
        <li>Message TTL</li>
        <li>PTP Queues and Pub/Sub Topics</li>
        <li>Durable Topics</li>
        <li>Temporary queues and topics</li>
        <li>Transaction support</li>
        <li>Client- or auto-acknowledgement of messages</li>
    </ul>
</section>
<section>
    <a name="unsupported"></a>
    <h2>Not Supported (yet)</h2>
    <ul>
        <li>FIFO (SQS does not guarantee strict message order)</li>
        <li>XA-compliance</li>
        <li>Expediting of high priority messages</li>
        <li>Message selectors</li>
        <li>Queue browsing (can still be accomplished through AWS console)</li>
        <li>Topic groups / heirarchies</li>
        <li>Extended Application Server Facilities (ConnectionConsumer)</li>
    </ul>
</section>
<section>
    <a name="sorta_supported"></a>
    <h2>Grey Area</h2>
    <p>SQS guarantees at-least-once delivery, whereas JMS requires once-and-only-once delivery.
        <a href="http://www.cloudstacking.com/?p=243">In practice, duplicate
        messages are very rare.</a>
        You can send millions of messages and never see a duplicate.  That said, they are still a possibility and your
        code needs to be able to handle them.
        If this is a big issue for you, let us know.  This could be prevented with
        some additional "magic" in Nevado, but this is an edge case, so we don't cover it yet.
    </p>
</section>
<section>
    <a name="message_size"></a>
    <h2>Message Size</h2>
    <p>SQS imposes a message body maximum of 64k.  Due to message serialization, this means an object upper-limit of
        48k in Nevado.  If you need larger payloads than this,
    we recommend that you store the payload in an external store like DynamoDB and use Nevado JMS to pass identifiers
    to the data.  Smaller messages also improve performance.</p>
</section>
</body>
</html>
